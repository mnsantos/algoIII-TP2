\subsection{Complejidad}

%The running time of Prim’s algorithm depends on how we implement the min-
%priority queue Q. If we implement Q as a binary min-heap (see Chapter 6), we
%can use the B UILD -M IN -H EAP procedure to perform lines 1–5 in O.V / time. The
%body of the while loop executes jV j times, and since each E XTRACT-M IN opera-
%tion takes O.lg V / time, the total time for all calls to E XTRACT-M IN is O.V lg V /.
%The for loop in lines 8–11 executes O.E/ times altogether, since the sum of the
%lengths of all adjacency lists is 2 jEj. Within the for loop, we can implement the
%test for membership in Q in line 9 in constant time by keeping a bit for each vertex
%that tells whether or not it is in Q, and updating the bit when the vertex is removed
%5from Q. The assignment in line 11 involves an implicit D ECREASE -K EY opera-
%tion on the min-heap, which a binary min-heap supports in O.lg V / time. Thus,
%the total time for Prim’s algorithm is O.V lg V C E lg V / D O.E lg V /, which is
%asymptotically the same as for our implementation of Kruskal’s algorithm.

La complejidad de Prim Modificado dependerá de la estructura utilizada para ir eligiendo aristas. El cuerpo del while se ejecuta C veces. El obtener mínimo dentro del while se ejecutará O(R) veces en total en donde cada operación de push, pop cuesta log(R) lo que equivale a O(log $(F+C)^2$) ya que $(F+C)^2$ es la mayor cantidad de aristas posibles. Como F es menor que C (enunciado), log($(C+F)^2$) $\subset$ log($C^2$). Por lo tanto la complejidad equivale a O(2 log C) $\subset$ O(log C). El for que se encarga de pushear las aristas adyacentes a la cola de prioridad también se ejecutará un total de R veces y la operación de push cuesta log(R) $\subset$ O(log C). Por lo tanto la complejidad total será de O(R*log(C)+R*log(C)) $\subset$ O(R*log(C)) como pedía el enunciado.
